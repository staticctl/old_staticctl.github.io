### 完成或正在进行的工作

1. 测试了 **for**循环
2. `[shift1, shift2, tmpval1] = registration_in_each_channel(ref_plane1(:,:,fix(ii/num_img)+1), img_plane1(:,:,mod(ii,num_img)+1));`
4. 文献[[阅读清单]]  **Multiple signal classification algorithm for super-resolution fluorescence microscopy**
5. 编写 **CDUA** 代码
 ---
### 存在的问题

1. **matlab** 没有正确识别程序的并行，生成了很多 **kernel**，或者说可读性有点差
2. 为什么不使用**matlab**自带的互相关呢？精度问题
3. **FFT2**不需要并行，主要的时间开销在图像校准，**dftregistration** 主要开销
4. 测试了 **Faster R-CNN** 代码，使用 **mmdection**，基于 **pytorch**，更新顶会的文章代码，或者一些顶会的代码是基于 **mmdection** 开发的
5. **x-z** 方向的**PSF**如何拍摄的，各种方向
6. 各向同性 和 各向异性
7. **oriented dipoles**  定向偶极子, 怎么理解？请老师解释
 ![[Pasted image 20221223102103.png]]
6. 


**12.26**  考试

#CUDA 


**思路：**

这个核函数实际上是将原来的 **Matlab** 函数中的一些部分转换为了 **CUDA** 的形式。对于每一对输入的 **buf1ft** 和 **buf2ft**，这个核函数会计算它们的互相关，并在互相关的反傅里叶变换中找到峰值位置。它还会计算两个图像之间的移位和误差度量。最后，如果需要，会计算 **buf2ft** 的对其版本。

这个核函数接受四个输入参数：**buf1ft**、**buf2ft**、**output** 和 **Greg**。**buf1ft** 和 **buf2ft** 是每个图像的傅里叶变换，而 **output** 是一个 **float** 型数组，用于存储输出结果。**Greg** 是一个 **cufftComplex** 型的指针，用于存储 **buf2ft** 的对齐版本（如果提供的话）。

在函数开始时，我们创建了正反傅里叶变换的计划，并为互相关和反互相关分配了内存。然后，我们使用 **CUFFT** 库执行了 **buf1ft** 和 **buf2ft** 的傅里叶变换，并计算了它们的互相关。

接下来，我们找到了互相关的峰值位置，并使用二次拟合来确定峰值的真实位置。最后，我们计算 **buf2ft** 的注册版本，并将输出结果写入 **output** 数组。


1. 创建正反傅里叶变换的计划，并分配内存来存储互相关和反互相关。

2. 计算两个输入图像的互相关，并执行反傅里叶变换以找到互相关峰值的位置。

3. 使用二次拟合确定互相关峰值的真实位置。

4. 计算两个输入图像之间的移位和相位差。

5. 如果指定了输出数组 Greg，则计算 buf2ft 的注册版本（全局相位差已补偿）的傅里叶变换。

6. 释放正反傅里叶变换的计划和为互相关和反互相关分配的内存。